/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Scanner;

import javax.annotation.Nullable;

public class MathOperationsApp {
    private static boolean applicationRunning = true;
    private static final int MAX_PAGE = 17;
    private static final int MIN_PAGE = 4;
    private static File nextFileToProcess;

    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (applicationRunning) {
            if (nextFileToProcess == null) {
                nextFileToProcess = getTheCurrentFileToBeProcessed();
            }
            displayMenu(nextFileToProcess);

            int choice = scanner.nextInt();
            switch (choice) {
                case 1:
                    System.out.println("Skipping the file and reading the next");
                    nextFileToProcess = getTheNextFile(nextFileToProcess);
                    updateLastPageFile(nextFileToProcess);
                    break;
                case 2:
                    System.out.println("Processing the file");
                    processFile(nextFileToProcess);
                    nextFileToProcess = getTheNextFile(nextFileToProcess);
                    updateLastPageFile(nextFileToProcess);
                    break;

                case 3:
                    System.out.println("Closing the application...");
                    System.exit(0);
                    break;
                default:
                    break;
            }
        }

    }

    private static void updateLastPageFile(File file) {
        try {
            Files.write(Paths.get("lastPage.txt"), file.getName().getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void processFile(File fileToProcess) {
        System.out.println("Are you ready to start with the mathematical operations from the file " + fileToProcess.getName());
        Scanner scanner = new Scanner(System.in);
        System.out.println("1. Yes");
        System.out.println("2. No");

        int correctAnswerCount = 0;
        int totalAnswerCount = 0;
        int totalInLessTwoMinutes = 0;

        int choice = scanner.nextInt();
        while (choice != 1) {
            System.out.println("Are you ready to start with the mathematical operations from the file " + fileToProcess.getName());
            System.out.println("1. Yes");
            System.out.println("2. No");
            choice = scanner.nextInt();
        }

        try {
            List<String> mathOperations = Files.readAllLines(fileToProcess.toPath());
            long startTime = System.currentTimeMillis();
            for (String mathOperation : mathOperations) {
                System.out.printf("Result for the next operation: %s%n", mathOperation);
                String userAnswer = scanner.nextLine();
                String userAnswerSanitized = userAnswer.replaceAll("\\D+", "");

                if (userAnswerSanitized.isEmpty()) {
                    System.out.println("Please provide an answer to the operation");
                    userAnswer = scanner.nextLine();
                    userAnswerSanitized = userAnswer.replaceAll("\\D+", "");
                }

                totalAnswerCount++;
                boolean wasCorrect = validateUserAnswer(mathOperation, userAnswerSanitized);
                long endTime = System.currentTimeMillis() - startTime;
                if (endTime < 120000) {
                    totalInLessTwoMinutes++;
                }
                if (wasCorrect) {
                    correctAnswerCount++;
                }
            }

            System.out.printf("You answered %d out of %d questions correctly%n", correctAnswerCount, totalAnswerCount);
            saveRegistryInRecordFile(correctAnswerCount, totalAnswerCount, totalInLessTwoMinutes, fileToProcess.getName());

        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }

    private static void saveRegistryInRecordFile(int correctAnswers, int totalAnswers, int totalInLessTwoMinutes, String filename) {
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm");

        String row = new StringBuilder()
                .append(filename)
                .append(",")
                .append(correctAnswers)
                .append(",")
                .append(correctAnswers - totalAnswers)
                .append(",")
                .append(totalInLessTwoMinutes)
                .append(",")
                .append(now.format(formatter))
                .append("\n")
                .toString();
        
                // how to append the last row into an existing CSV file
                try {
                    Files.write(Paths.get("record.csv"), row.getBytes(), StandardOpenOption.APPEND);
                } catch (IOException e) {
                    e.printStackTrace();
                }
    }

    private static boolean validateUserAnswer(String mathOperation, String userAnswer) {
        String[] operationParts = mathOperation.split(" ");
        int operand1 = Integer.parseInt(operationParts[0]);
        int operand2 = Integer.parseInt(operationParts[2]);
        String operator = operationParts[1];

        int result = 0;

        switch (operator) {
            case "+":
                result = operand1 + operand2;
                return Integer.parseInt(userAnswer) == result;
            case "-":
                result = operand1 - operand2;
                return Integer.parseInt(userAnswer) == result;
            case "*":
                result = operand1 * operand2;
                return Integer.parseInt(userAnswer) == result;
            case "/":
                result = operand1 / operand2;
                return Integer.parseInt(userAnswer) == result;
            default:
                throw new IllegalArgumentException("Invalid operator");
        }
    }

    private static void displayMenu(File file) {
        System.out.printf("Please select the action to perform in the %s file:%n", file.getName());
        System.out.println("1. Skip the file");
        System.out.println("2. Process the file");
        System.out.println("3. Exit");
        System.out.println("Enter your choice: ");
    }

    private static File getTheNextFile(File currentFile) {
        String filename = currentFile.getName();
        String pageNumber = filename.replaceAll("\\D", "");
        int number = Integer.parseInt(pageNumber);

        if (number < MAX_PAGE) {
            number++;
        } else {
            number = MIN_PAGE;
        }

        String newFilePath = new StringBuilder()
                .append("pages/")
                .append("page")
                .append(number)
                .append(".txt")
                .toString();

        return new File(newFilePath);
    }

    /**
     * Retrieves the current file to be processed based on the last page recorded in
     * "lastPage.txt".
     * Searches for the file with the same name as the last page in the "pages"
     * directory.
     *
     * @return The current file to be processed, or null if the file is not found or
     *         an error occurs.
     */
    @Nullable
    private static File getTheCurrentFileToBeProcessed() {
        try {
            String lastPage = Files.readAllLines(Paths.get("lastPage.txt")).get(0);
            File pagesDirectory = new File("pages");
            File[] fileList = pagesDirectory.listFiles();

            for (File file : fileList) {
                if (file.getName().equals(lastPage)) {
                    return file;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        return null;
    }
}
